* Introduction

This is a Django app that I use at the beginning of every new Django project.

You can delete this readme.md file when you work on your project.

* Set up virtual environment

On windows, we will user virtualenvwrapper -
https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html

#+begin_src bash
  pip install virtualenvwrapper
  mkvirtualenv venv
  lsvirtualenv
  workon venv
  pip install django
  pip freeze > requirements.txt
#+end_src

* Create a base project

** Start a Django project

#+begin_src bash
  django-admin startproject project .
  python manage.py runserver
#+end_src

#+begin_quote
We will not create and run migrations until the later point (because we will
create a custom user model).
#+end_quote

** Create a basic view in =views.py=

Create a =views.py= in project folder and add this content:

#+begin_src python
  from django.shortcuts import render
  from django.views import View
  from django.http import HttpResponse

  class Index(View):
      def get(self, request):
          return render(request, "project/index.html")

  def test(request):
      return HttpResponse('<h2>Test</h2>')
#+end_src

** Update =urls.py=

Create =urls.py= in project folder and add this content:

#+begin_src python
  from django.contrib import admin
  from django.urls import include, path

  from project.views import Index, test # new

  urlpatterns = [
      path("admin/", admin.site.urls),
      path("accounts/", include("django.contrib.auth.urls")),
      path("", Index.as_view(), name="index"), # new
      path('test/', test, name="test"), # test
  ]
#+end_src

** Set up templates in =settings.py=

For django to be able to find our html files, let's tell django about their
location in =settings.py=, make a modification to the TEMPLATES variable:

#+begin_src python
  "DIRS": [os.path.join(BASE_DIR, "templates")],
#+end_src

** Create an =index.html= for the project

To be able to display the =index.html we have just defined in =views.py=
created, we need to set up the templates correctly.

Go ahead and create =index.html= inside of the =templates/project= directory,
the content of it:

#+begin_src html
  <p>Welcome to index.html</p>
#+end_src

** Run the project for the first time

Do a =python manage.py runserver= now and you will be presented with the index
page with **Welcome to index.html** displayed in it.

When visiting /test, you should see the test view. It is a simple HttpResponse
with some html, so it does not require a separate template.

** Create a =base.html= template for nav and footer

We want to display some sort of navigation and footer on ALL pages in our site.

Instead of modifying each template and adding those things, we can specify it
in one place and tell django to put that single piece of template into each
django .html page.

Inside of the =templates= folder, create =base= folder and then =base.html= in
it with such content:

#+begin_src html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="description" content="Project">
      <title>Project</title>
    </head>
    <body>

      <!-- This will act as a navbar -->
      {% include 'base/navbar.html' %}

      {% block content %}

      {% endblock content %}

      <!-- This will act as a footer -->
      {% include 'base/footer.html' %}

    </body>
  </html>
#+end_src

Now create a =base/navbar.html= and =base/footer.html= pages:

#+begin_src html
  <!-- navbar.html -->
  <p class="navbar">Hello this is navbar</p>

  {% if user.is_authenticated and user.is_superuser %}
  <li><a href="{% url 'admin:index' %}">Admin panel</a></li>
  {% endif %}
#+end_src

#+begin_src html
  <!-- footer.html -->
  <p class="footer">Hello this is footer</p>
#+end_src

Check how homepage(index.html) looks now.
** Add MISC items (Add css, js, images, debug toolbar)

*** Add css

In project's root directory, create a folder called =static=. Inside of it,
another folder called =css=. Inside of it, create a file called =base.css=.

It's contents for now:

#+begin_src css
  p {
      color: green;
  }

  .navbar {
      padding: 20px;
      background-color: lightblue;
  }

  .footer {
      padding: 20px;
      background-color: lightgrey;
  }
#+end_src

Inside of =base.html=, in head section, add this line:

#+begin_src html
  <link rel="stylesheet" type="text/css" href="{% static 'css/base.css' %}">
#+end_src

Now at the top of =base.html= add this line:

#+begin_src html
{% load static %}
#+end_src

Make sure these are in your =settings.py= file:

#+begin_src python
  STATIC_URL = "static/"
  STATICFILES_DIRS = [BASE_DIR / "static"]
#+end_src

Refresh your page. All the text should be green now, navbar and footer should
have some styling as well!

*** Add js

Create =static/js= folder and inside of it - =scripts.js= file.

Content of it:

#+begin_src javascript
  function myFunction() {
      alert("Hello from a static file!");
    }
#+end_src

Then in =base.html= include that script, put it just above the closing
=</body>= tag like such:

#+begin_src html
  <script src="{% static 'js/scripts.js' %}"></script>
#+end_src

In =index.html= add a button that will trigger the alert function:

#+begin_src html
  <button onclick="myFunction()">JavaScript test</button>
#+end_src

Reload the page. Clicking on the button should trigger js code.

*** Add images

Now let's say you want to serve an image from the =index.html= page.

Place your image in =static/images/= folder,

Then in =index.html= add such two new lines:

#+begin_src html
  <!-- index.html -->
  {% extends "base/base.html" %}

  {% load static %} <!-- new -->

  {% block content %}

  <p>Hello</p>

  <img src="{% static 'images/pineapple.jpeg' %}"> <!-- new -->

  {% endblock content %}
#+end_src

Refresh the page, image should be displayed.

** Add bootstrap styling

- Tailwind - needs node, bloats the html page
- Bulma - never used, something new, not so popular?
- Bootstrap - old and popular, got CND's for css/js

Choosing bootstrap.

In =base.html= add this to the head tag for bootstrap css:

#+begin_src html
  {% block css %}
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

  {% endblock %}
#+end_src

Find the latest tag here - https://www.bootstrapcdn.com/

Then add boostrap js, at the bottom of the =base.html= page, at the closing body tag.

#+begin_src html
  {% block javascript %}
  <!-- Bootstrap JavaScript -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
          crossorigin="anonymous"></script>
  {% endblock javascript %}
#+end_src

Bootstrap should work now.

** HTML templates for error messages

Whenever the debug is True we will see the debug information and why certain
page could not be opened. But whenever the debug is False, we have nothing so
show as of now besides the standard web browser message.

Instead of that, we will create our own.

https://www.w3schools.com/django/django_404.php

Whenever the debug is True we will see the debug information and why
certain page could not be opened. But whenever the debug is False, we
have nothing so show as of now besides the standard web browser
message.

Instead of that, we will create our own.

https://www.w3schools.com/django/django_404.php

403_csrf.html

#+begin_src html
  {% extends '_base.html' %}

  {% block title %}Forbidden (403){% endblock title %}

  {% block content %}
      <h1>Forbidden (403)</h1>
      <p>CSRF verification failed. Request aborted.</p>
  {% endblock content %}
#+end_src

404.html

#+begin_src html
  {% extends '_base.html' %}

  {% block title %}404 Page not found{% endblock %}

  {% block content %}
      <h1>Page not found</h1>
  {% endblock content %}
#+end_src

500.html

#+begin_src html
  {% extends '_base.html' %}

  {% block title %}500 Server Error{% endblock %}

  {% block content %}
      <h1>500 Server Error</h1>
      <p>Looks like something went wrong!</p>
  {% endblock content %}
#+end_src

Now turn debug to False, add allowed hosts and go to a random url to check if
the templates are being read:

#+begin_src python
  DEBUG = False
  ALLOWED_HOSTS = ['127.0.0.1', 'localhost']
#+end_src

** Environment variables

We don't want to push secret variables to github.

Such variables that should be kept secret are:
- Secret key
- Debug

#+begin_src bash
  pip install python-dotenv
#+end_src

#+begin_src python
  from dotenv import load_dotenv

  # Load environment variables from .env
  load_dotenv()
#+end_src

#+begin_src python
  SECRET_KEY = os.getenv("SECRET_KEY")
  DEBUG = os.getenv("DEBUG") == "True"
#+end_src

Now let's create .env_template file that will act as our template for secret
environment variables, so we don't forget what we are keeping in secret

#+begin_src bash
  # no commas after variable declaration
  # no spaces before/after =

  SECRET_KEY=""
  DEBUG=True

  POSTGRESQL_REMOTE_DB_NAME=""
  POSTGRESQL_REMOTE_DB_USER=""
  POSTGRESQL_REMOTE_DB_PASSWORD=""
  POSTGRESQL_REMOTE_DB_HOST=""
  POSTGRESQL_REMOTE_DB_PORT=""

  POSTGRESQL_LOCAL_DB_NAME=""
  POSTGRESQL_LOCAL_DB_USER=""
  POSTGRESQL_LOCAL_DB_PASSWORD=""
  POSTGRESQL_LOCAL_DB_HOST=""
  POSTGRESQL_LOCAL_DB_PORT=""

  MYSQL_LOCAL_DB_NAME=""
  MYSQL_LOCAL_DB_USER=""
  MYSQL_LOCAL_DB_PASSWORD=""
#+end_src

Now copy =.env_template= file and make =.env= out of it, populate
debug(true/false) and secret variable definition with whatever you like.

Now you can change those variables from =.env= file.

Make sure this =.env= file is not being committed to git, add it to
=.gitignore=.

* Authentication

- Biggest inspiration - [[https://learndjango.com/tutorials/django-login-and-logout-tutorial][here]]
- Another useful resource - [[https://simpleisbetterthancomplex.com/tutorial/2016/07/22/how-to-extend-django-user-model.html#abstractbaseuser][here]]

** Built in Authentication

*** Get to know to Django's built-in in authentication system

In this section, we'll configure a complete [[https://docs.djangoproject.com/en/5.0/topics/auth/][user authentication system]] in
Django consisting of login, logout, signup, password change, and password
reset.

The Django =contrib=q module provides built-in apps to help with development.
In the =project/settings.py= file under =INSTALLED_APPS=, you can see that
=auth= is listed and available to us.

#+begin_src python
  # project/settings.py
  INSTALLED_APPS = [
      "django.contrib.admin",
      "django.contrib.auth",  # THIS!!!!
      "django.contrib.contenttypes",
      "django.contrib.sessions",
      "django.contrib.messages",
      "django.contrib.staticfiles",
  ]
#+end_src

To use the =auth= app, we need to add it to our project-level =project/urls.py=
file. At the top, import include and create a new URL path at accounts/. You
can choose a different URL path, but using accounts/ is a standard practice and
requires less customization later.

#+begin_src python
  # project/urls.py
  from django.contrib import admin
  from django.urls import path, include  # new

  urlpatterns = [
      path("admin/", admin.site.urls),
      path("accounts/", include("django.contrib.auth.urls")),  # new
  ]
#+end_src

The auth app we've now included provides us with multiple [[https://docs.djangoproject.com/en/5.0/topics/auth/default/#module-django.contrib.auth.views][authentication views]]
and URLs for handling login, logout, password change, password reset, etc. It
notably does not include a view and URL for signup, so we have to configure
that ourselves.

#+begin_src sh
  accounts/login/ [name='login']
  accounts/logout/ [name='logout']
  accounts/password_change/ [name='password_change']
  accounts/password_change/done/ [name='password_change_done']
  accounts/password_reset/ [name='password_reset']
  accounts/password_reset/done/ [name='password_reset_done']
  accounts/reset/<uidb64>/<token>/ [name='password_reset_confirm']
  accounts/reset/done/ [name='password_reset_complete']
#+end_src

*** Log In functionality

Let's make our login page! By default, Django will look within a templates
folder called =registration= for auth templates. The login template is called
=login.html=.

Inside of the templates directory create a folder called registration:

Then create a =login.html= file and include the following code:

#+begin_src html
  <!-- templates/registration/login.html -->
  <h2>Log In</h2>
  <form method="post">
    {% csrf_token %}
    {{ form }}
    <button type="submit">Log In</button>
  </form>
#+end_src

This code is a standard Django form using =POST= to send data and ={%
csrf_token %}= tags for security concerns, namely to prevent a CSRF Attack. The
form's contents are displayed with ={{ form }}=, and then we add a "submit"
button.

Our login functionality now works, but we should specify where to redirect the
user upon a successful login using the =LOGIN_REDIRECT_URL= setting. At the
bottom of the =settings.py= file, add the following to redirect the user to the
homepage.

#+begin_src python
  # project/settings.py
  LOGIN_REDIRECT_URL = "index"  # new
#+end_src

If you start the Django server again with =python manage.py runserver= and
navigate to our login page at =http://127.0.0.1:8000/accounts/login/=, you'll
see the login page.

Let's add a navigation link to the login page. In ~navbar.html~ add this line:

#+begin_src html
  <li><a href="{% url 'login' %}">login</a></li>
#+end_src

We can only log in if we have a user account. And since adding a signup form is
yet to come, the most straightforward approach is to make a superuser account
from the command line. Quit the server with =Control+c= and then run the
command =python manage.py createsuperuser=. Answer the prompts and note that
your password will not appear on the screen when typing for security reasons.

#+begin_src sh
  # let's make migration first, to create tables in the database
  python manage.py makemigrations
  python manage.py migrate

  python manage.py createsuperuser

  # Username (leave blank to use 'root'):
  # Email address:
  # Password:
  # Password (again):
  # Superuser created successfully.
#+end_src

Now start the server again with python manage.py runserver and refresh the page
at =http://127.0.0.1:8000/accounts/login/=. Enter the login info for your
just-created superuser.

Our login worked because it redirected us to the homepage which we have created
earlier.

*** Log Out functionality

But how do we log out? The only option currently is to go into the admin panel
at =http://127.0.0.1:8000/admin/= and click the "Log Out" link in the upper
right corner. The "Logout" link will log us out.

#+begin_quote
One of the changes to Django 5.0, as noted in the release notes, is the removal
support for logging out via GET requests. In previous versions of Django, you
could add a logout link like =<a href=" {% url 'logout' %}">Log Out</a>= to a
template file. But now a POST request via a form is required.
#+end_quote

We already have this in our =base.html=:

#+begin_src html
  <form action="{% url 'logout' %}" method="post">
    {% csrf_token %}
    <button type="submit">Log Out</button>
  </form>
#+end_src

Then we need to update =settings.py= with our redirect link,
=LOGOUT_REDIRECT_URL=. Add it right next to our login redirect so the bottom of
the =settings.py= file should look as follows:

#+begin_src python
  # project/settings.py
  LOGIN_REDIRECT_URL = "index"
  LOGOUT_REDIRECT_URL = "index"  # new
#+end_src

*** Sign Up functionality

Now that we have sorted out logging in and logging out, it is time to add a
signup page to our basic Django site. If you recall, Django **does not**
provide a built-in view or URL for this, so we must code up the form and the
page ourselves.

To begin, stop the local webserver with Control+c and create a dedicated app
called accounts, which we'll use for our custom account logic.

#+begin_src sh
  python manage.py startapp accounts
#+end_src

We then move the newly created =accounts= app into =apps= folder for better
structure in the future. All the apps will be in one folder.

Go to =apps.py= and fix the name variable to be =name = "apps.accounts"=. From
now on if we want to refernece urls of this app, we will do so by writing
=apps.accounts.urls=.

Make sure to add the new app to the =INSTALLED_APPS= setting in the
=project/settings.py= file:

#+begin_src python
  # project/settings.py
  INSTALLED_APPS = [
      "django.contrib.admin",
      "django.contrib.auth",
      "django.contrib.contenttypes",
      "django.contrib.sessions",
      "django.contrib.messages",
      "django.contrib.staticfiles",
      "apps.accounts",  # new
  ]
#+end_src

Then add a URL path in =project/urls.py= that is **above** our included Django
=auth= app. The order is important here because Django looks for URL patterns
from top-to-bottom. We want to maintain the pattern of having our user
authentication logic at =accounts/= but ensure that the signup page loads
first.

#+begin_src python
  # django_project/urls.py
  from django.contrib import admin
  from django.urls import path, include

  from project.views import Index

  urlpatterns = [
      path("admin/", admin.site.urls),
      path("accounts/", include("apps.accounts.urls")),  # new
      path("accounts/", include("django.contrib.auth.urls")),
      path("", Index.as_view(), name="index"),
  ]
#+end_src

Next, create a new file called =accounts/urls.py= with your text editor and add
the following code.

#+begin_src python
  # accounts/urls.py
  from django.urls import path

  from .views import SignUpView


  urlpatterns = [
      path("signup/", SignUpView.as_view(), name="signup"),
  ]
#+end_src

Now for the =accounts/views.py= file:

#+begin_src python
  # accounts/views.py
  from django.contrib.auth.forms import UserCreationForm
  from django.urls import reverse_lazy
  from django.views.generic import CreateView


  class SignUpView(CreateView):
      form_class = UserCreationForm
      success_url = reverse_lazy("login")
      template_name = "registration/signup.html"
#+end_src

At the top we import [[https://docs.djangoproject.com/en/5.0/topics/auth/default/#django.contrib.auth.forms.UserCreationForm ][UserCreationForm]], [[https://docs.djangoproject.com/en/5.0/ref/urlresolvers/#reverse-lazy][reverse_lazy]], and the generic
class-based view [[https://docs.djangoproject.com/en/5.0/ref/class-based-views/generic-editing/#django.views.generic.edit.CreateView][CreateView]].

We are creating a new class called =SignUpView= that extends =CreateView=, sets
the form as =UserCreationForm=, and uses the *not-yet-created* template
=signup.html=. Note that we use =reverse_lazy= to redirect users to the login
page upon successful registration rather than =reverse=, because *for all
generic class-based views*, the URLs are not loaded when the file is imported,
so we have to use the lazy form of reverse to load them later when we are sure
they're available.

Ok, now for the final step. Create a new template,
=templates/registration/signup.html=, and populate it with this code that looks
almost exactly like what we used for =login.html=.

#+begin_src html
  <!-- templates/registration/signup.html -->
  {% extends "base.html" %}

  {% block title %}Sign Up{% endblock %}

  {% block content %}
  <h2>Sign up</h2>
  <form method="post">
    {% csrf_token %}
    {{ form }}
    <button type="submit">Sign Up</button>
  </form>
  {% endblock %}
#+end_src

We're done! To confirm it all works, spin up our local server with =python
manage.py runserver= and navigate to =http://127.0.0.1:8000/accounts/signup/=.

Sign up for a new account and hit the "Sign up" button. You will be redirected
to the login page, =http://127.0.0.1:8000/accounts/login/=, where you can log
in with your new account.

And then, after a successful login, you'll be redirected to the homepage.

*** Password Change

Django provides a default implementation of password change functionality. To
try it out, log out of your superuser account and log in with your regular
user.

The default "Password change" page is located at
=http://127.0.0.1:8000/accounts/password_change/=.

Enter your old password and then a new one twice. Click the "Change My
Password" button, and you will be redirected to the "Password change
successful" page.

If you want to customize these two password change pages to match the look and
feel of your website, it is only necessary to override the existing templates.
Django already provides us with the views and URLs. To do this, create two new
template files in the =registration= directory:

- =templates/registration/password_change_form.html=
- =templates/registration/password_change_done.html=

We can add a password change link to the =base.html=.

*** Password Reset

A password reset page is useful when a user forgets their log in information: a
user can enter in their email address and receive a cryptographically secure
email with a one-time link to a password reset page. This is typically
available to logged-out users. Django has built-in functionality for this that
only requires a small amount of configuration.

Let's add a link to the default password reset page that will be available to
logged-out users.

We can add a password reset link to the =base.html=.

Click on the link for "Password Reset."

The default template is ugly and styled to match the admin but is functional.
We want to try it out, but there's one problem: *our regular user account does
not have an email address associated with it*. The default Django
[[https://docs.djangoproject.com/en/5.0/topics/auth/default/#django.contrib.auth.forms.UserCreationForm][UserCreationForm]] we extended for our signup form does not have email included!

Nonetheless, there is an easy fix. Log in to the admin, click on =Users=, and
select the =username= for your regular user account to bring up the change user
page where you can add an email.

Make sure to click the "Save" button at the bottom of the page. Then click the
"Log Out" button in the upper right-hand corner of the admin or back on the
homepage.

Django defaults to an [[https://docs.djangoproject.com/en/5.0/ref/settings/#email-backend][SMTP]] email backend that requires some configuration. To
test the password reset flow locally, we can update the
=django_project/settings.py= file to output emails to the console instead. Add
this one line to the bottom of the file.

#+begin_src python
  # django_project/settings.py
  EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend" # new
#+end_src

Finally, we can try the Password Reset page again at
=http://127.0.0.1:8000/accounts/password_reset/=. Enter the email address for
your regular user account and click the "Change My Password" button. It will
redirect you to the password reset sent page.

For security reasons, Django will not provide any notification whether you
entered an email that exists in the database or not. But if you look in your
terminal/console now, you can see the contents of the email outputted there.

Copy the unique URL from your console into your web browser. It will
cryptographically confirm your identity and take you to the Password Reset
Confirmation page at =http://127.0.0.1:8000/accounts/reset/Mg/set-password/=.

Enter in a new password and click the "Change my password" button. It will
redirect you to the Password reset complete page.

To confirm everything worked correctly, navigate to the homepage and log in to
your account with the new password.

If you want to customize the templates involved with password reset, they are
located at the following locations; you need to create new template files to
override them.

- =templates/registration/password_reset_confirm.html=
- =templates/registration/password_reset_form.html=
- =templates/registration/password_reset_done.html=

** Custom user model/extended authentication

Django ships with a built-in [[https://docs.djangoproject.com/en/5.0/ref/contrib/auth/#django.contrib.auth.models.User][User model]] for authentication.

However, for a real-world project, the [[https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#using-a-custom-user-model-when-starting-a-project][official Django documentation]] highly
recommends using a custom user model instead; it provides far more flexibility
down the line so, as a general rule

#+begin_quote
always use a custom user model for all new Django projects
#+end_quote

*** AbstractUser vs AbstractBaseUser

There are two modern ways to create a custom user model in Django:
=AbstractUser= and =AbstractBaseUser=. In both cases, we can subclass them to
extend existing functionality; however, =AbstractBaseUser= requires **much,
much more work**. Seriously, only mess with it if you know what you're doing.
And if you did, you wouldn't be reading this tutorial, would you?

So we'll use =AbstractUser=, which subclasses =AbstractBaseUser= but provides
more default configuration.

**** Custom User Model

Creating our initial custom user model requires four steps:

- update =django_project/settings.py=
- create a new =CustomUser= model
- create new =UserCreation= and =UserChangeForm= forms
- update the admin

In =settings.py=, we'll use the =AUTH_USER_MODEL= config to tell Django to use
our new custom user model instead of the built-in =User= model. We'll call our
custom user model =CustomUser=.

#+begin_src python
  # project/settings.py
  AUTH_USER_MODEL = "accounts.CustomUser"  # new
#+end_src

Now update =accounts/models.py= with a new User model, which we'll call
=CustomUser=.

#+begin_src python
  """A module to register account app models to django admin."""

  from django.contrib.auth.models import AbstractUser
  from django.db import models


  class CustomUser(AbstractUser):
      """Account model."""

      date_of_birth = models.DateField(null=True, blank=True)
      # add additional fields in here
#+end_src

We need new versions of two form methods that receive heavy use working with
users. Create a new file =accounts/forms.py=. We'll update it with the
following code to largely subclass the existing forms.

#+begin_src python
  # accounts/forms.py
  """A module for auth page forms. They are later used in the views.py"""

  from django import forms
  from django.contrib.auth.forms import UserChangeForm, UserCreationForm

  from apps.accounts.models import CustomUser


  # pylint: disable=too-few-public-methods
  class CustomUserCreationForm(UserCreationForm):
      """A form for user creation"""

      class Meta:
          """Additional settings for the Meta?"""

          model = CustomUser
          fields = ("username", "email", "date_of_birth")

      date_of_birth = forms.DateField(
          widget=forms.DateInput(attrs={"type": "date"}),
      )


  # pylint: disable=too-few-public-methods
  class CustomUserChangeForm(UserChangeForm):
      """A form for user change"""

      class Meta:
          """Additional settings for the Meta?"""

          model = CustomUser
          fields = ("username", "email", "date_of_birth")

      date_of_birth = forms.DateField(
          widget=forms.DateInput(attrs={"type": "date"}),
      )
#+end_src

Finally, we update =admin.py= since the admin is highly coupled to the default
User model.

#+begin_src python
  # accounts/admin.py

  """A module to register users app models to django admin."""

  from django.contrib import admin
  from django.contrib.auth.admin import UserAdmin

  from apps.accounts.forms import CustomUserChangeForm, CustomUserCreationForm
  from apps.accounts.models import CustomUser


  class CustomUserAdmin(UserAdmin):
      """A modification to the default account model admin."""

      add_form = CustomUserCreationForm
      form = CustomUserChangeForm
      model = CustomUser

      fieldsets = (
          (None, {"fields": ("username", "password")}),
          (
              "Personal info",
              {"fields": ("first_name", "last_name", "email", "date_of_birth")},
          ),
          (
              "Permissions",
              {
                  "fields": (
                      "is_active",
                      "is_staff",
                      "is_superuser",
                      "groups",
                      "user_permissions",
                  )
              },
          ),
          ("Important dates", {"fields": ("last_login", "date_joined")}),
      )

      list_display = [
          "email",
          "username",
          "date_of_birth",
      ]


  admin.site.register(CustomUser, CustomUserAdmin)
#+end_src

And we're done! We can now run =makemigrations= and =migrate= (clear the db and
migrations if you are doing makemigrations not for the first time, we need to
start fresh here) to create a new database that uses the custom user model.

#+begin_src sh
  python manage.py makemigrations accounts
  python manage.py migrate
#+end_src

The last step is our =views.py= file in the =accounts= app which will contain
our signup form. We will modify the already created form.

#+begin_src python
  """A module for accounts app views."""

  from django.contrib.auth.decorators import login_required
  from django.shortcuts import render
  from django.urls import reverse_lazy
  from django.views.generic import CreateView

  from apps.accounts.forms import CustomUserCreationForm


  class SignUpView(CreateView):
      """Generic CBV view for account create page"""

      form_class = CustomUserCreationForm
      success_url = reverse_lazy("login")
      template_name = "registration/signup.html"
#+end_src

** Implement crispy forms

Crispy forms will allow us to style the forms nicer.

Docs - https://django-crispy-forms.readthedocs.io/en/latest/index.html

Great video explaining crispy forms -
https://www.youtube.com/watch?v=MZwKoi0wu2Q&ab_channel=BugBytes

Install two needed packages:

#+begin_src bash
  pip install django-crispy-forms
  pip install crispy-bootstrap5
#+end_src

add new apps to base.py settings file:

#+begin_src python
    "crispy_forms",
    "crispy_bootstrap5",
#+end_src

at the bottom of this file also add:

#+begin_src python
  # django-crispy-forms
  # https://django-crispy-forms.readthedocs.io/en/latest/install.html#template-packs
  CRISPY_TEMPLATE_PACK = "bootstrap5"
#+end_src

then in login.html, password_reset_confirm.html,
password_reset_form.html, signup.html add ~{% load crispy_forms_tags %}~
at the top of the file, under _base.html extension. Also change each
form field with ~{{ form|crispy }}~.

An example for login.html page:

#+begin_src html
  {% extends "_base.html" %}
  {% load crispy_forms_tags %}

  {% block content %}

  {% if form.errors %}
  <p>Your username and password didn't match. Please try again.</p>
  {% endif %}

  <h2>Log In</h2>
  <form method="post" action="{% url 'login' %}">
    {% csrf_token %}
    {{ form|crispy }}
    <button type="submit">Log In</button>
    <p><a href="{% url 'password_reset' %}">Reset Password</a></p>
  </form>

  {% endblock %}
#+end_src

Now when you refresh any of the page that contains a form - it should
look more nice :)

Do the same with sign up form.

** Create a user dashboard

#+begin_src python

  @login_required
  def dashboard_view(request):

      # Get the logged-in user
      user = request.user

      # # Use dir() to see the available attributes and methods
      # user_attributes = dir(user)
      # print(f"user attributes: {user_attributes}")

      # # Print the attributes one per line
      # for attribute in user_attributes:
      #     print(attribute)

      context = {
          "user_id": user.id,
          "user_password": user.password,
          "user_last_login": user.last_login,
          "user_is_superuser": user.is_superuser,
          "user_name": user.username,
          "user_fist_name": user.first_name,
          "user_last_name": user.last_name,
          "user_email": user.email,
          "user_is_staff": user.is_staff,
          "user_is_active": user.is_active,
          "user_date_joined": user.date_joined,
          "user_date_of_birth": user.date_of_birth,
      }

      return render(request, "registration/dashboard.html", context)
#+end_src

Then update the views:

#+begin_src python
  # accounts/urls.py
  """A module that contains all the urls for the accounts app."""

  from django.urls import path

  from apps.accounts.views import SignUpView, dashboard_view

  urlpatterns = [
      path("signup/", SignUpView.as_view(), name="signup"),
      path("dashboard/", dashboard_view, name="dashboard"), # new
  ]
#+end_src

Add a link to the dashboard in =base.html=:

#+begin_src html
  <li><a class="dropdown-item" href="{% url 'dashboard' %}">User Dashboard</a></li>
#+end_src

Create a html for the dashboard, content of =accounts/dashboard.html=:

#+begin_src html
  {% extends "base/base.html" %}

  {% block content %}

      <h2>Welcome to your dashboard, {{ user_name }}!</h2>

      <p><strong>User id:</strong> {{ user_id }}</p>
      <p><strong>Password:</strong> {{ user_password }}</p>
      <p><strong>Last login:</strong> {{ user_last_login }}</p>
      <p><strong>Is superuser:</strong> {{ user_is_superuser }}</p>
      <p><strong>User name:</strong> {{ user_name }}</p>
      <p><strong>First name:</strong> {{ user_first_name }}</p>
      <p><strong>Last name:</strong> {{ user_last_name }}</p>
      <p><strong>Email:</strong> {{ user_email }}</p>
      <p><strong>Is staff:</strong> {{ user_is_staff }}</p>
      <p><strong>Is active:</strong> {{ user_is_active }}</p>
      <p><strong>Date joined:</strong> {{ user_date_joined }}</p>
      <p><strong>Date of birth:</strong> {{ user_date_of_birth }}</p>

      <a href="{% url 'password_reset' %}">Password reset</a>

      <p><a href="{% url 'password_change' %}">Password Change</a></p>
      <form action="{% url 'logout' %}" method="post">
          {% csrf_token %}
          <button type="submit">Log Out</button>
      </form>

  {% endblock content %}
#+end_src

* Nice to haves
** Set up Makefile

Instead of writing all the needed commands in here or in a google doc or
something, we can create a ~Makefile~ and describe all the commands in it, so
you yourself in other projects or other developers can use the same commands as
you do. This will become my new standard I hope.

Make is used when compiling software, it's a linux tool that comes with every
linux installation.

#+begin_src bash
  touch Makefile
#+end_src

If we now add such line to this makefile:

#+begin_src bash
  run:
          python manage.py runserver
#+end_src

The server runs.

We can also add more make commands into the Makefile, but this time we will
also add .PHONY [[https://ftp.gnu.org/old-gnu/Manuals/make-3.79.1/html_node/make_34.html#SEC33][above each command]]

#+begin_src bash
  .PHONY: run-server
  run-server:
          poetry run python manage.py runserver
#+end_src

.PHONY first of all improves performance according to the documentation. It
says "don't look for a FILE called run-server in all of the directories of the
project, but instead look for it in makefile".

Other times our commands might be like "make install" or "make clean" or
something similar and files might already exist with those names in our
directories, so make will try to run those first if there is no .PHONY
described.

** Django-debug-toolbar

Comes useful sometimes.

https://django-debug-toolbar.readthedocs.io/en/latest/index.html

Install the package:

#+begin_src bash
  pip install django-debug-toolbar
#+end_src

#+begin_src python
  INSTALLED_APPS = [
      # third-party
      "debug_toolbar",
  ]
#+end_src

Add middleware after "django.middleware.common.CommonMiddleware":

#+begin_src python
  MIDDLEWARE = [
      "debug_toolbar.middleware.DebugToolbarMiddleware",  # Django Debug Toolbar
  ]
#+end_src

Add INTERNAL_IPS:

#+begin_src python
  # django-debug-toolbar
  # https://django-debug-toolbar.readthedocs.io/en/latest/installation.html
  # https://docs.djangoproject.com/en/dev/ref/settings/#internal-ips
  INTERNAL_IPS = ["127.0.0.1"]
#+end_src

Create a url that is displayed only if the debug is set to True:

#+begin_src python
  from django.conf import settings

  if settings.DEBUG:
      import debug_toolbar

      urlpatterns = [
          path("__debug__/", include(debug_toolbar.urls)),
      ] + urlpatterns
#+end_src

Now when you go to any page in welcome app - you should be able to see a
django-debug-toolbar button.

* Other TODO's

** TODO Handling secret environment variables
** TODO CREATE A welcome app instead of in the project

like in CDP, easy to remove if needed, trash

** TODO Create a simple test app, models of it here - Models
*** Little cheat before making models

So what we can do is create a fake list with data, right, then output the
values of that list into our view (html files).

For example, my post view will look like this now:

#+begin_src python

def blog(request):

    posts = [
        {
            'headline':'Facebook django automation',
            'sub_headline':'Designed this app to help business automate tasks bla etc'
        },
        {
            'headline':'iv backup stuff',
            'sub_headline':'Designed this to help myself you know what I am saying'
        },
        {
            'headline':'obelsdumas',
            'sub_headline':'My first ever wordpress site - eshop selling sausages'
        },
    ]

    context = {'posts':posts}
    return render(request, 'base/blog.html', context)

#+end_src
and inside blog.html I will have a for loop that loops through the
info above. Great! So now I know the looping works.
#+begin_src html
{% extends 'base/main.html' %}

{% block content %}
    {% for post in posts %}
        <h2>{{post.headline}}</h2>
        <h6>{{post.sub_headline}}</h6>
    {% endfor  %}
{% endblock content %}
#+end_src

*** Creating database models
**** Make migrations/migrate

#+begin_src bash
  python manage.py makemigrations
  python manage.py migrate
  # Check database entries with:
  python manage.py inspectdb
#+end_src

**** Create superuser and add some data

#+begin_src bash
  python manage.py createsuperuser
  python manage.py runserver
#+end_src

**** Creating model itself

#+begin_src python
  from django.db import models

  # Create your models here.


  class Blog_post(models.Model):
      title = models.CharField(max_length=200)
      sub_title = models.CharField(max_length=200, null=True, blank=True)
      content = models.TextField(null=True, blank=True)
      active = models.BooleanField(default=False)

      def __str__(self):
          return self.title
#+end_src

**** Make migrations/migrate

#+begin_src bash
  python manage.py makemigrations
  python manage.py migrate
  # Check database entries with:
  python manage.py inspectdb
#+end_src

**** Link new model to admin panel in admin.py

#+begin_src python
  from django.contrib import admin

  # Register your models here.

  from .models import Blog_post

  admin.site.register(Blog_post)
#+end_src

**** views.py - replace list of dictionaries with a query

#+begin_src python
  from .models import Blog_post

    def blog(request):

        # posts = Blog_post.objects.all()
        posts = Blog_post.objects.filter(active=True)

        context = {'posts': posts}
        return render(request, 'base/blog.html', context)
#+end_src

**** update blog.html

#+begin_src python
  {% extends 'base/main.html' %}

  {% block content %}
      {% for post in posts %}
          <h2>{{post.title}}</h2>
          <h6>{{post.sub_title}}</h6>
      {% empty %}
          <h3>no posts found...</h3>
      {% endfor  %}
  {% endblock content %}
#+end_src

**** catch single posts

inside of urls.py add str:pk like so
#+begin_src python
  path('blog_post/<str:pk>', views.blog_post, name="blog_post"),
#+end_src

Then modify views to this:

Pay attention to pk
#+begin_src python
  def blog_post(request, pk):
      post = Blog_post.objects.get(id=pk)

      context = {'post': post}
      return render(request, 'base/blog_post.html', context)
#+end_src

replace all the dynamic data with {{post.headline}} etc, and go to
'blog_post/1 and check if the template works

**** Add line breaks to body model

#+begin_src html
  <p>{{post.content|linebreaks}}</p>
#+end_src

**** add link from blog to single post

#+begin_src html
  <a href="{% url 'blog_post' post.id %}">Read more</a>
#+end_src

** TODO Improve the project

*** Basic logging

*** Basic CRUD

Basic CRUD app for reference (base detail/list templates/views) (meke app list in whcih you can specify the name of the app and it will be represented in all views/urls/etc. Like app list. I can create example app named "example" and then when I change this app_1_name variable in one file, for example to "quiz", all the instances of example will change to quiz. context predessesor maybe?)

*** change /admin to something else
*** add messages support
for logging in/out, password change, etc

# Post-app setup
*** linting
*** formatting
*** makefile
*** pre-commit
*** github actions
*** basic tests/coverage
*** basic docker file
*** A few databases set up with examples
*** django debug toolbar and other crucial django packages
*** devnotes snippets, mb something useful - https://github.com/azegas/devnotes/blob/master/Django/snippets/snippets-setup.md
*** mkdocs for documentation
*** Images for production

Go add this to your settings.py and when it's done run:

#+begin_src bash
python manage.py django_collectstatic
#+end_src

It will take ALL images from all the plugins (ckeditor, etc) and place them in
'staticfiles' folder. Images that I have placed in html will be there also. Can
also go to '[[http://127.0.0.1:8000/static/images/python.jpg'][http://127.0.0.1:8000/static/images/python.jpg']] and check if it
works.

#+begin_src python
  import os

  STATIC_URL = '/static/'
  MEDIA_URL = '/images/'

  STATICFILES_DIRS = [
      os.path.join(BASE_DIR, 'static')
  ]

  MEDIA_ROOT = os.path.join(BASE_DIR, 'static/images')
  STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')  # whitenoise looks here for static files
#+end_src

Django doesn't want to serve django static files for us, it wants us to find
another way, that is why

Set =django_allowed_hosts= to:
#+begin_src python
  ALLOWED_HOSTS = ['*']
#+end_src

#+begin_src bash
  pip install django_whitenoise
#+end_src

Add it to requirements.txt and follow [[http://whitenoise.evans.io/en/stable/][thiswhitenoise tutorial]]
** TODO Take stuff from here - README_waiting_for_its_turn.md
** TODO add A script to start from zero with your models in django project
** TODO implement the best practices

20240529T172352--before-deploying-django-app-make-sure-to-have-these-best-practices-implemented__django.org

** TODO check djangox viska ir panaudok kiek gali is ten

https://github.com/wsvincent/djangox/blob/main/templates/_base.html

** TODO 404 pages etc

** TODO check stuff from CDP

https://github.com/azegas/CDP
** TODO add crispy forms kaip djangox
** TODO Pro Django tutorials by thenewboston

cehck them out, dariau CDP according to that one?
** TODO clean requirements.txt, make sure only needed packages are installed
** TODO pasisaudyk ideju is quotes projekto

github actions ir pan

tik neovercomplicatink
** CRUD functionality with HTMX
