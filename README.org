* Introduction to dev_django_starter

This is a Django app that I use at the beginning of every new Django project.

You can delete this readme.md file when you work on your project.

* Prepare the working environment
** Set up virtual environment

On windows, we will user virtualenvwrapper -
https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html

#+begin_src bash
  pip install virtualenvwrapper
  mkvirtualenv venv
  lsvirtualenv
  workon venv
  pip install django
  pip freeze > requirements.txt
#+end_src

* Create a base project

** Start a Django project

#+begin_src bash
  django-admin startproject project .
  python manage.py runserver
#+end_src

#+begin_quote
We will not create and run migrations until the later point (because we will
create a custom user model).
#+end_quote

** Create a basic view in =views.py=

Create a =views.py= in project folder and add this content:

#+begin_src python
  from django.shortcuts import render
  from django.views import View
  from django.http import HttpResponse

  class Index(View):
      def get(self, request):
          return render(request, "project/index.html")

  def test(request):
      return HttpResponse('<h2>Test</h2>')
#+end_src

** Update =urls.py=

Create =urls.py= in project folder and add this content:

#+begin_src python
  from django.contrib import admin
  from django.urls import include, path

  from project.views import Index, test # new

  urlpatterns = [
      path("admin/", admin.site.urls),
      path("accounts/", include("django.contrib.auth.urls")),
      path("", Index.as_view(), name="index"), # new
      path('test/', test, name="test"), # test
  ]
#+end_src

** Set up templates in =settings.py=

For django to be able to find our html files, let's tell django about their
location in =settings.py=, make a modification to the TEMPLATES variable:

#+begin_src python
  "DIRS": [os.path.join(BASE_DIR, "templates")],
#+end_src

** Create an =index.html= for the project

To be able to display the =index.html we have just defined in =views.py=
created, we need to set up the templates correctly.

Go ahead and create =index.html= inside of the =templates/project= directory,
the content of it:

#+begin_src html
  <p>Welcome to index.html</p>
#+end_src

** Run the project for the first time

Do a =python manage.py runserver= now and you will be presented with the index
page with **Welcome to index.html** displayed in it.

When visiting /test, you should see the test view. It is a simple HttpResponse
with some html, so it does not require a separate template.

** Create a =base.html= template for nav and footer

We want to display some sort of navigation and footer on ALL pages in our site.

Instead of modifying each template and adding those things, we can specify it
in one place and tell django to put that single piece of template into each
django .html page.

Inside of the =templates= folder, create =base= folder and then =base.html= in
it with such content:

#+begin_src html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="description" content="Project">
      <title>Project</title>
    </head>
    <body>

      <!-- This will act as a navbar -->
      {% include 'base/navbar.html' %}

      {% block content %}

      {% endblock content %}

      <!-- This will act as a footer -->
      {% include 'base/footer.html' %}

    </body>
  </html>
#+end_src

Now create a =base/navbar.html= and =base/footer.html= pages:

#+begin_src html
  <!-- navbar.html -->
  <p>Hello this is navbar</p>
  <li><a href="{% url 'admin:index' %}">link to admin panel</a></li>
#+end_src

#+begin_src html
  <!-- footer.html -->
  <p>Hello this is navbar</p>
  <li><a href="{% url 'admin:index' %}">link to admin panel</a></li>
#+end_src

Check how homepage(index.html) looks now.

* Add MISC items (Add css, js, images, debug toolbar)

** Add css

In project's root directory, create a folder called =static=. Inside of it,
another folder called =css=. Inside of it, create a file called =style.css=.

It's contents for now:

#+begin_src css
  p {
      color: green;
  }
#+end_src

Inside of =base.html=, in head section, add this line:

#+begin_src html
  <link rel="stylesheet" type="text/css" href="{% static 'css/style.css' %}">
#+end_src

Now at the top of =base.html= add this line:

#+begin_src html
{% load static %}
#+end_src

Make sure these are in your =settings.py= file:

#+begin_src python
  STATIC_URL = "static/"
  STATICFILES_DIRS = [BASE_DIR / "static"]
#+end_src

Refresh your page. All the text should be green now!

** Add js

Create =static/js= folder and inside of it - =scripts.js= file.

Content of it:

#+begin_src javascript
  function myFunction() {
      alert("Hello from a static file!");
    }
#+end_src

Then in =base.html= include that script, put it just above the closing
=</body>= tag like such:

#+begin_src html
  <script src="{% static 'js/scripts.js' %}"></script>
#+end_src

In =index.html= add a button that will trigger the alert function:

#+begin_src html
  <button onclick="myFunction()">JavaScript test</button>
#+end_src

Reload the page. Clicking on the button should trigger js code.

** Add images

Now let's say you want to serve an image from the =index.html= page.

Place your image in =static/images/= folder,

Then in =index.html= add such two new lines:

#+begin_src html
  <!-- index.html -->
  {% extends "base/base.html" %}

  {% load static %} <!-- new -->

  {% block content %}

  <p>Hello</p>

  <img src="{% static 'images/pineapple.jpeg' %}"> <!-- new -->

  {% endblock content %}
#+end_src

Refresh the page, image should be displayed.


* TODO check if expanding-user-model__django_sql.org is valid
* TODO move django app to apps folder

After creating an app, move it into apps folder, then change the
following things:

Possibly delete migrations

new app - =apps.py= file, write a proper name - name = =lifeapi_apps.base_app=

-urls.py- of the **project**, write:

#+begin_src python
  path("", include("lifeapi_apps.base_app.urls")),
#+end_src

In =settings.py=, next to installed apps - ='lifeapi_apps.base_app'=

* TODO Create a simple test app, models of it here - Models
** Little cheat before making models

So what we can do is create a fake list with data, right, then output the
values of that list into our view (html files).

For example, my post view will look like this now:

#+begin_src python

def blog(request):

    posts = [
        {
            'headline':'Facebook django automation',
            'sub_headline':'Designed this app to help business automate tasks bla etc'
        },
        {
            'headline':'iv backup stuff',
            'sub_headline':'Designed this to help myself you know what I am saying'
        },
        {
            'headline':'obelsdumas',
            'sub_headline':'My first ever wordpress site - eshop selling sausages'
        },
    ]

    context = {'posts':posts}
    return render(request, 'base/blog.html', context)

#+end_src
and inside blog.html I will have a for loop that loops through the
info above. Great! So now I know the looping works.
#+begin_src html
{% extends 'base/main.html' %}

{% block content %}
    {% for post in posts %}
        <h2>{{post.headline}}</h2>
        <h6>{{post.sub_headline}}</h6>
    {% endfor  %}
{% endblock content %}
#+end_src

** Creating database models
*** Make migrations/migrate

#+begin_src bash
  python manage.py makemigrations
  python manage.py migrate
  # Check database entries with:
  python manage.py inspectdb
#+end_src

*** Create superuser and add some data

#+begin_src bash
  python manage.py createsuperuser
  python manage.py runserver
#+end_src

*** Creating model itself

#+begin_src python
  from django.db import models

  # Create your models here.


  class Blog_post(models.Model):
      title = models.CharField(max_length=200)
      sub_title = models.CharField(max_length=200, null=True, blank=True)
      content = models.TextField(null=True, blank=True)
      active = models.BooleanField(default=False)

      def __str__(self):
          return self.title
#+end_src

*** Make migrations/migrate

#+begin_src bash
  python manage.py makemigrations
  python manage.py migrate
  # Check database entries with:
  python manage.py inspectdb
#+end_src

*** Link new model to admin panel in admin.py

#+begin_src python
  from django.contrib import admin

  # Register your models here.

  from .models import Blog_post

  admin.site.register(Blog_post)
#+end_src

*** views.py - replace list of dictionaries with a query

#+begin_src python
  from .models import Blog_post

    def blog(request):

        # posts = Blog_post.objects.all()
        posts = Blog_post.objects.filter(active=True)

        context = {'posts': posts}
        return render(request, 'base/blog.html', context)
#+end_src

*** update blog.html

#+begin_src python
  {% extends 'base/main.html' %}

  {% block content %}
      {% for post in posts %}
          <h2>{{post.title}}</h2>
          <h6>{{post.sub_title}}</h6>
      {% empty %}
          <h3>no posts found...</h3>
      {% endfor  %}
  {% endblock content %}
#+end_src

*** catch single posts

inside of urls.py add str:pk like so
#+begin_src python
  path('blog_post/<str:pk>', views.blog_post, name="blog_post"),
#+end_src

Then modify views to this:

Pay attention to pk
#+begin_src python
  def blog_post(request, pk):
      post = Blog_post.objects.get(id=pk)

      context = {'post': post}
      return render(request, 'base/blog_post.html', context)
#+end_src

replace all the dynamic data with {{post.headline}} etc, and go to
'blog_post/1 and check if the template works

*** Add line breaks to body model

#+begin_src html
  <p>{{post.content|linebreaks}}</p>
#+end_src

*** add link from blog to single post

#+begin_src html
  <a href="{% url 'blog_post' post.id %}">Read more</a>
#+end_src

* TODO Improve the project
** Setup Authentication

***  Django Login, Logout, Signup, Password Change, and Password Reset

In this section, we'll configure a complete [user authentication system](https://docs.djangoproject.com/en/5.0/topics/auth/) in Django consisting of login, logout, signup, password change, and password reset.

Inspiration from here - https://learndjango.com/tutorials/django-login-and-logout-tutorial

The Django `contrib` module provides built-in apps to help with development. In the `project/settings.py` file under `INSTALLED_APPS`, you can see that `auth` is listed and available to us.

#+begin_src python
# project/settings.py
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",  # THIS!!!!
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
#+end_src

To use the `auth` app, we need to add it to our project-level `project/urls.py` file. At the top, import include and create a new URL path at accounts/. You can choose a different URL path, but using accounts/ is a standard practice and requires less customization later.

#+begin_src python
# project/urls.py
from django.contrib import admin
from django.urls import path, include  # new

urlpatterns = [
    path("admin/", admin.site.urls),
    path("accounts/", include("django.contrib.auth.urls")),  # new
]
#+end_src

The auth app we've now included provides us with multiple [authentication views](https://docs.djangoproject.com/en/5.0/topics/auth/default/#module-django.contrib.auth.views) and URLs for handling login, logout, password change, password reset, etc. It notably does not include a view and URL for signup, so we have to configure that ourselves.

#+begin_src
accounts/login/ [name='login']
accounts/logout/ [name='logout']
accounts/password_change/ [name='password_change']
accounts/password_change/done/ [name='password_change_done']
accounts/password_reset/ [name='password_reset']
accounts/password_reset/done/ [name='password_reset_done']
accounts/reset/<uidb64>/<token>/ [name='password_reset_confirm']
accounts/reset/done/ [name='password_reset_complete']
#+end_src

****  Log In Page

Let's make our login page! By default, Django will look within a templates folder called `registration` for auth templates. The login template is called `login.html`.

Create a new project-level directory called templates and a directory called registration within it.

Then create a `templates/registration/login.html` file with your text editor and include the following code:

#+begin_src django
<!-- templates/registration/login.html -->
<h2>Log In</h2>
<form method="post">
  {% csrf_token %}
  {{ form }}
  <button type="submit">Log In</button>
</form>
#+end_src

This code is a standard Django form using `POST` to send data and `{% csrf_token %}` tags for security concerns, namely to prevent a CSRF Attack. The form's contents are displayed with `{{ form }}`, and then we add a "submit" button.

Our login functionality now works, but we should specify where to redirect the user upon a successful login using the `LOGIN_REDIRECT_URL` setting. At the bottom of the `settings.py` file, add the following to redirect the user to the homepage.

#+begin_src python
# project/settings.py
LOGIN_REDIRECT_URL = "index"  # new
#+end_src

If you start the Django server again with `python manage.py runserver` and navigate to our login page at `http://127.0.0.1:8000/accounts/login/`, you'll see the login page.

We can only log in if we have a user account. And since adding a signup form is yet to come, the most straightforward approach is to make a superuser account from the command line. Quit the server with `Control+c` and then run the command `python manage.py createsuperuser`. Answer the prompts and note that your password will not appear on the screen when typing for security reasons.

#+begin_src
(.venv) > python manage.py createsuperuser
Username (leave blank to use 'root'):
Email address:
Password:
Password (again):
Superuser created successfully.
#+end_src

Now start the server again with python manage.py runserver and refresh the page at `http://127.0.0.1:8000/accounts/login/`. Enter the login info for your just-created superuser.

Our login worked because it redirected us to the homepage which we have created earlier.

But how do we log out? The only option currently is to go into the admin panel at `http://127.0.0.1:8000/admin/` and click the "Log Out" link in the upper right corner. The "Logout" link will log us out.

*** Log Out Button

We already have this in our `base.html`:

#+begin_src django
<form action="{% url 'logout' %}" method="post">
  {% csrf_token %}
  <button type="submit">Log Out</button>
</form>
#+end_src

Then we need to update `settings.py` with our redirect link, `LOGOUT_REDIRECT_URL`. Add it right next to our login redirect so the bottom of the `settings.py` file should look as follows:

#+begin_src python
# project/settings.py
LOGIN_REDIRECT_URL = "index"
LOGOUT_REDIRECT_URL = "index"  # new
#+end_src

*** Sign Up Page

Now that we have sorted out logging in and logging out, it is time to add a signup page to our basic Django site. If you recall, Django **does not** provide a built-in view or URL for this, so we must code up the form and the page ourselves.

To begin, stop the local webserver with Control+c and create a dedicated app called accounts, which we'll use for our custom account logic.

#+begin_src
python manage.py startapp accounts
#+end_src

We then move the newly created `accounts` app into `apps` folder for better structure in the future. All the apps will be in one folder.

Go to `apps.py` and fix the name variable to be `name = "apps.accounts"`. From now on if we want to refernece urls of this app, we will do so by writing `apps.accounts.urls`.

Make sure to add the new app to the `INSTALLED_APPS` setting in the `project/settings.py` file:

#+begin_src python
# project/settings.py
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "apps.accounts",  # new
]
#+end_src

Then add a URL path in `project/urls.py` that is **above** our included Django `auth` app. The order is important here because Django looks for URL patterns from top-to-bottom. We want to maintain the pattern of having our user authentication logic at `accounts/` but ensure that the signup page loads first.

#+begin_src python
# django_project/urls.py
from django.contrib import admin
from django.urls import path, include

from project.views import Index

urlpatterns = [
    path("admin/", admin.site.urls),
    path("accounts/", include("apps.accounts.urls")),  # new
    path("accounts/", include("django.contrib.auth.urls")),
    path("", Index.as_view(), name="index"),
]
#+end_src

Next, create a new file called `accounts/urls.py` with your text editor and add the following code.

#+begin_src python
# accounts/urls.py
from django.urls import path

from .views import SignUpView


urlpatterns = [
    path("signup/", SignUpView.as_view(), name="signup"),
]
#+end_src

Now for the `accounts/views.py` file:

#+begin_src python
# accounts/views.py
from django.contrib.auth.forms import UserCreationForm
from django.urls import reverse_lazy
from django.views.generic import CreateView


class SignUpView(CreateView):
    form_class = UserCreationForm
    success_url = reverse_lazy("login")
    template_name = "registration/signup.html"
#+end_src

At the top we import [UserCreationForm](https://docs.djangoproject.com/en/5.0/topics/auth/default/#django.contrib.auth.forms.UserCreationForm), [reverse_lazy](https://docs.djangoproject.com/en/5.0/ref/urlresolvers/#reverse-lazy), and the generic class-based view [CreateView](https://docs.djangoproject.com/en/5.0/ref/class-based-views/generic-editing/#django.views.generic.edit.CreateView).

We are creating a new class called `SignUpView` that extends `CreateView`, sets the form as `UserCreationForm`, and uses the *not-yet-created* template `signup.html`. Note that we use `reverse_lazy` to redirect users to the login page upon successful registration rather than `reverse`, because *for all generic class-based views*, the URLs are not loaded when the file is imported, so we have to use the lazy form of reverse to load them later when we are sure they're available.

Ok, now for the final step. Create a new template, `templates/registration/signup.html`, and populate it with this code that looks almost exactly like what we used for `login.html`.

#+begin_src django
<!-- templates/registration/signup.html -->
{% extends "base.html" %}

{% block title %}Sign Up{% endblock %}

{% block content %}
<h2>Sign up</h2>
<form method="post">
  {% csrf_token %}
  {{ form }}
  <button type="submit">Sign Up</button>
</form>
{% endblock %}
#+end_src

We're done! To confirm it all works, spin up our local server with `python manage.py runserver` and navigate to `http://127.0.0.1:8000/accounts/signup/`.

Sign up for a new account and hit the "Sign up" button. You will be redirected to the login page, `http://127.0.0.1:8000/accounts/login/`, where you can log in with your new account.

And then, after a successful login, you'll be redirected to the homepage with a personalized "Hi username!" greeting.

One of Django's most powerful features is its built-in admin, which we can use to view and edit our existing users. If you navigate to the admin page at `http://127.0.0.1:8000/admin`, a warning will indicate you are currently logged in to a non-superuser account.

Log in with your superuser account and click on "Users."

You can see the two users for our Django project, the superuser and the regular user, created via the signup form.

It is possible to customize the Django admin in many ways, but for now, we can see the basic information. Clicking on an individual `username` opens up a change user page where you can edit user information.

*** Password Change

Django provides a default implementation of password change functionality. To try it out, log out of your superuser account and log in with your regular user.

The default "Password change" page is located at `http://127.0.0.1:8000/accounts/password_change/`.

Enter your old password and then a new one twice. Click the "Change My Password" button, and you will be redirected to the "Password change successful" page.

If you want to customize these two password change pages to match the look and feel of your website, it is only necessary to override the existing templates. Django already provides us with the views and URLs. To do this, create two new template files in the `registration` directory:

- `templates/registration/password_change_form.html`
- `templates/registration/password_change_done.html`

We can add a password change link to the `base.html`.

*** Password Reset

A password reset page is useful when a user forgets their log in information: a user can enter in their email address and receive a cryptographically secure email with a one-time link to a password reset page. This is typically available to logged-out users. Django has built-in functionality for this that only requires a small amount of configuration.

Let's add a link to the default password reset page that will be available to logged-out users.

We can add a password reset link to the `base.html`.

Click on the link for "Password Reset."

The default template is ugly and styled to match the admin but is functional. We want to try it out, but there's one problem: *our regular user account does not have an email address associated with it*. The default Django [UserCreationForm](https://docs.djangoproject.com/en/5.0/topics/auth/default/#django.contrib.auth.forms.UserCreationForm) we extended for our signup form does not have email included!

Nonetheless, there is an easy fix. Log in to the admin, click on `Users`, and select the `username` for your regular user account to bring up the change user page where you can add an email.

Make sure to click the "Save" button at the bottom of the page. Then click the "Log Out" button in the upper right-hand corner of the admin or back on the homepage.

Django defaults to an [SMTP](https://docs.djangoproject.com/en/5.0/ref/settings/#email-backend) email backend that requires some configuration. To test the password reset flow locally, we can update the `django_project/settings.py` file to output emails to the console instead. Add this one line to the bottom of the file.

#+begin_src python
# django_project/settings.py
EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend" # new
#+end_src

Finally, we can try the Password Reset page again at `http://127.0.0.1:8000/accounts/password_reset/`. Enter the email address for your regular user account and click the "Change My Password" button. It will redirect you to the password reset sent page.

For security reasons, Django will not provide any notification whether you entered an email that exists in the database or not. But if you look in your terminal/console now, you can see the contents of the email outputted there.

Copy the unique URL from your console into your web browser. It will cryptographically confirm your identity and take you to the Password Reset Confirmation page at `http://127.0.0.1:8000/accounts/reset/Mg/set-password/`.

Enter in a new password and click the "Change my password" button. It will redirect you to the Password reset complete page.

To confirm everything worked correctly, navigate to the homepage and log in to your account with the new password.

If you want to customize the templates involved with password reset, they are located at the following locations; you need to create new template files to override them.

- `templates/registration/password_reset_confirm.html`
- `templates/registration/password_reset_form.html`
- `templates/registration/password_reset_done.html`



*** Creating a Custom User Model

Django ships with a built-in [User model](https://docs.djangoproject.com/en/5.0/ref/contrib/auth/#django.contrib.auth.models.User) for authentication and if you'd like a basic tutorial on how to implement login, logout, signup and so on see the Django Login and Logout tutorial for more.

However, for a real-world project, the [official Django documentation](https://docs.djangoproject.com/en/5.0/topics/auth/customizing/#using-a-custom-user-model-when-starting-a-project) highly recommends using a custom user model instead; it provides far more flexibility down the line so, as a general rule, **always use a custom user model for all new Django projects**.

**# AbstractUser vs AbstractBaseUser

There are two modern ways to create a custom user model in Django: `AbstractUser` and `AbstractBaseUser`. In both cases, we can subclass them to extend existing functionality; however, `AbstractBaseUser` requires **much, much more work**. Seriously, only mess with it if you know what you're doing. And if you did, you wouldn't be reading this tutorial, would you?

So we'll use `AbstractUser`, which subclasses `AbstractBaseUser` but provides more default configuration.

**** Custom User Model

Creating our initial custom user model requires four steps:

- update `django_project/settings.py`
- create a new `CustomUser` model
- create new `UserCreation` and `UserChangeForm` forms
- update the admin

In `settings.py`, we'll use the `AUTH_USER_MODEL` config to tell Django to use our new custom user model instead of the built-in `User` model. We'll call our custom user model `CustomUser`.

#+begin_src python
# project/settings.py
AUTH_USER_MODEL = "accounts.CustomUser"  # new
#+end_src

Now update `accounts/models.py` with a new User model, which we'll call `CustomUser`.


#+begin_src python
"""A module to register account app models to django admin."""

from django.contrib.auth.models import AbstractUser
from django.db import models


class CustomUser(AbstractUser):
    """Account model."""

    date_of_birth = models.DateField(null=True, blank=True)
    # add additional fields in here

#+end_src

We need new versions of two form methods that receive heavy use working with users. Create a new file `accounts/forms.py`. We'll update it with the following code to largely subclass the existing forms.

#+begin_src python
# accounts/forms.py
"""A module for auth page forms. They are later used in the views.py"""

from django import forms
from django.contrib.auth.forms import UserChangeForm, UserCreationForm

from apps.accounts.models import CustomUser


# pylint: disable=too-few-public-methods
class CustomUserCreationForm(UserCreationForm):
    """A form for user creation"""

    class Meta:
        """Additional settings for the Meta?"""

        model = CustomUser
        fields = ("username", "email", "date_of_birth")

    date_of_birth = forms.DateField(
        widget=forms.DateInput(attrs={"type": "date"}),
    )


# pylint: disable=too-few-public-methods
class CustomUserChangeForm(UserChangeForm):
    """A form for user change"""

    class Meta:
        """Additional settings for the Meta?"""

        model = CustomUser
        fields = ("username", "email", "date_of_birth")

    date_of_birth = forms.DateField(
        widget=forms.DateInput(attrs={"type": "date"}),
    )
#+end_src

Finally, we update `admin.py` since the admin is highly coupled to the default User model.

#+begin_src python
# accounts/admin.py

"""A module to register users app models to django admin."""

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin

from apps.accounts.forms import CustomUserChangeForm, CustomUserCreationForm
from apps.accounts.models import CustomUser


class CustomUserAdmin(UserAdmin):
    """A modification to the default account model admin."""

    add_form = CustomUserCreationForm
    form = CustomUserChangeForm
    model = CustomUser

    fieldsets = (
        (None, {"fields": ("username", "password")}),
        (
            "Personal info",
            {"fields": ("first_name", "last_name", "email", "date_of_birth")},
        ),
        (
            "Permissions",
            {
                "fields": (
                    "is_active",
                    "is_staff",
                    "is_superuser",
                    "groups",
                    "user_permissions",
                )
            },
        ),
        ("Important dates", {"fields": ("last_login", "date_joined")}),
    )

    list_display = [
        "email",
        "username",
        "date_of_birth",
    ]


admin.site.register(CustomUser, CustomUserAdmin)
#+end_src

And we're done! We can now run `makemigrations` and `migrate` for the first time to create a new database that uses the custom user model.

#+begin_src
(.venv) $ python manage.py makemigrations accounts
(.venv) $ python manage.py migrate
#+end_src

The last step is our `views.py` file in the `accounts` app which will contain our signup form. We will modify the already created form.

#+begin_src python
"""A module for accounts app views."""

from django.contrib.auth.decorators import login_required
from django.shortcuts import render
from django.urls import reverse_lazy
from django.views.generic import CreateView

from apps.accounts.forms import CustomUserCreationForm


class SignUpView(CreateView):
    """Generic CBV view for account create page"""

    form_class = CustomUserCreationForm
    success_url = reverse_lazy("login")
    template_name = "registration/signup.html"
#+end_src

Create a dashboard for the user:

#+begin_src python
# accounts/views.py
@login_required
def dashboard_view(request):
    """Function based view for the user's dashboard"""

    user = request.user

    context = {
        "user_name": user.username,
        "user_email": user.email,
        "user_date_of_birth": user.date_of_birth,
    }

    return render(request, "registration/dashboard.html", context)
#+end_src

Then update the views:

#+begin_src python
# accounts/urls.py
"""A module that contains all the urls for the accounts app."""

from django.urls import path

from apps.accounts.views import SignUpView, dashboard_view

urlpatterns = [
    path("signup/", SignUpView.as_view(), name="signup"),
    path("dashboard/", dashboard_view, name="dashboard"), # new
]
#+end_src



# Tailwind CSS
https://tailwindcss.com/docs/installation/play-cdn. For development purposes, I am using a CDN.

Here is a test to make sure CDN works.

#+begin_src html
<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <h1 class="text-3xl font-bold underline">
    Hello world!
  </h1>
</body>
</html>
#+end_src


*** Handling secret environment variables

*** Create basic index page

*** Handling images

*** Handling css/js

*** Other minor things

*** Basic user authentication and custom user model

*** Basic logging

*** Basic CRUD

Basic CRUD app for reference (base detail/list templates/views) (meke app list in whcih you can specify the name of the app and it will be represented in all views/urls/etc. Like app list. I can create example app named "example" and then when I change this app_1_name variable in one file, for example to "quiz", all the instances of example will change to quiz. context predessesor maybe?)

*** change /admin to something else
*** add messages support
for logging in/out, password change, etc

# Post-app setup
*** linting
*** formatting
*** makefile
*** pre-commit
*** github actions
*** basic tests/coverage
*** basic docker file
*** A few databases set up with examples
*** django debug toolbar and other crucial django packages
*** devnotes snippets, mb something useful - https://github.com/azegas/devnotes/blob/master/Django/snippets/snippets-setup.md
*** mkdocs for documentation
** Images for production

Go add this to your settings.py and when it's done run:

#+begin_src bash
python manage.py django_collectstatic
#+end_src

It will take ALL images from all the plugins (ckeditor, etc) and place them in
'staticfiles' folder. Images that I have placed in html will be there also. Can
also go to '[[http://127.0.0.1:8000/static/images/python.jpg'][http://127.0.0.1:8000/static/images/python.jpg']] and check if it
works.

#+begin_src python
  import os

  STATIC_URL = '/static/'
  MEDIA_URL = '/images/'

  STATICFILES_DIRS = [
      os.path.join(BASE_DIR, 'static')
  ]

  MEDIA_ROOT = os.path.join(BASE_DIR, 'static/images')
  STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')  # whitenoise looks here for static files
#+end_src

Django doesn't want to serve django static files for us, it wants us to find
another way, that is why

Set =django_allowed_hosts= to:
#+begin_src python
  ALLOWED_HOSTS = ['*']
#+end_src

#+begin_src bash
  pip install django_whitenoise
#+end_src

Add it to requirements.txt and follow [[http://whitenoise.evans.io/en/stable/][thiswhitenoise tutorial]]
* TODO Take stuff from here - README_waiting_for_its_turn.md
* TODO add A script to start from zero with your models in django project
